on:
  workflow_dispatch:
  push:
    branches: [ master, add/gh-action-prod ]

name: Deploy Production CGK

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '20'

      - name: Check Node.js Version
        run: node --version

  version-tag:
    needs: build
    name: Git Version Tagging
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      publish_docs: ${{ steps.check_commits.outputs.publish_docs }}
      append_notes: ${{ steps.check_commits.outputs.append_notes }}
      commit_details: ${{ steps.check_commits.outputs.commit_details }}
    steps:
      - uses: actions/checkout@v3
        with:
          ref: ${{ github.head_ref }}
          fetch-depth: 0

      - name: Determine if rerun
        id: check_rerun
        run: |
          if [ "${{ github.event_name }}" == "workflow_run" ]; then
            echo "This is a rerun"
            echo "::set-output name=rerun::true"
          else
            echo "This is a fresh run"
            echo "::set-output name=rerun::false"
          fi

      - name: Create Version Tagging
        if: steps.check_rerun.outputs.rerun == 'false'
        id: version
        uses: codacy/git-version@2.7.0
        with:
          prefix: "v"
          major-identifier: "break:"
          minor-identifier: "feat:"

      - name: Get Previous Tag
        if: steps.check_rerun.outputs.rerun == 'false'
        id: previous-tag
        run: |
          git fetch --tags
          PREVIOUS_TAG=$(git describe --tags --abbrev=0)
          echo "PREVIOUS_TAG=$PREVIOUS_TAG" >> $GITHUB_ENV

      - name: Push Tagging
        if: steps.check_rerun.outputs.rerun == 'false'
        uses: actions/github-script@v5
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            github.rest.git.createRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: 'refs/tags/${{ steps.version.outputs.version }}',
              sha: context.sha
            })

      - name: Create release notes
        if: steps.check_rerun.outputs.rerun == 'false'
        uses: actions/github-script@v4.0.2
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
                let releaseNotes = await github.request('POST /repos/${{github.repository}}/releases', {
                  tag_name: '${{ steps.version.outputs.version }}',
                  generate_release_notes: true
                });

      - name: Check commit messages for keywords
        if: steps.check_rerun.outputs.rerun == 'false'
        id: check_commits
        run: |
          PUBLISH_DOCS=false
          APPEND_NOTES=false
          COMMIT_DETAILS=""
          for COMMIT in $(git rev-list ${{ github.event.before }}..${{ github.sha }}); do
            COMMIT_MESSAGE=$(git log -1 --pretty=%s $COMMIT)
            COMMIT_DETAILS="${COMMIT_DETAILS}\n- ${COMMIT_MESSAGE}"
            if echo "$COMMIT_MESSAGE" | grep -E "feat:|break:"; then
              PUBLISH_DOCS=true
            fi
            if echo "$COMMIT_MESSAGE" | grep -E "fix:"; then
              APPEND_NOTES=true
            fi
          done
          COMMIT_DETAILS=$(echo -e "$COMMIT_DETAILS" | sed '/^$/d' | sed 's/,/\\,/g' | sed 's/:/\\:/g')
          echo "::set-output name=publish_docs::$PUBLISH_DOCS"
          echo "::set-output name=append_notes::$APPEND_NOTES"
          echo "::set-output name=commit_details::$(echo "$COMMIT_DETAILS" | sed ':a;N;$!ba;s/\n/\\n/g')"
          echo "::set-output name=version::${{ steps.version-tagging.outputs.version }}"
          echo "version=${{ steps.version-tagging.outputs.version }}"
          echo "publish_docs=$PUBLISH_DOCS"
          echo "append_notes=$APPEND_NOTES"
          echo "commit_details=$COMMIT_DETAILS"
        shell: bash

  create-confluence-page:
    runs-on: ubuntu-latest
    needs: version-tag
    if: needs.version-tag.outputs.publish_docs == 'true'
    steps: 
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          ref: ${{ github.head_ref }}
          fetch-depth: 0
          
      - name: Get PR description
        uses: actions/github-script@v6
        id: get_pr_data
        with:
          script: |
            const prData = (
              await github.rest.repos.listPullRequestsAssociatedWithCommit({
                commit_sha: context.sha,
                owner: context.repo.owner,
                repo: context.repo.repo,
              })
            ).data[0];
            
            const description = prData.body;
            const backgroundMatch = description.match(/### Background([\s\S]*?)(###|$)/);
            const background = backgroundMatch ? backgroundMatch[1].trim() : '';
            console.log(background)
            return { background };
  
      - name: Extract JIRA Issue Key from PR Description
        id: extract-jira-key
        env:
          PR_DESCRIPTION: ${{ steps.get_pr_data.outputs.background }}"
        run: |
          jira_issue_key=$(echo "$PR_DESCRIPTION" | grep -oE '[A-Z]+-[0-9]+' | head -n 1)
          if [ -z "$jira_issue_key" ]; then
            echo "No JIRA issue key found in the PR description."
            exit 1
          fi
          sanitized_jira_issue_key=$(echo "$jira_issue_key" | sed 's/[^a-zA-Z0-9_-]//g')
          echo "jira_issue_key=$sanitized_jira_issue_key" >> $GITHUB_ENV
        shell: bash
  
      - name: Fetch JIRA Issue Details
        id: fetch-jira-details
        run: |
          response=$(curl -u ${{ vars.CONFLUENCE_EMAIL }}:${{ secrets.CONFLUENCE_API_TOKEN }} \
            -X GET -H "Content-Type: application/json" \
            "https://agrim.atlassian.net/rest/api/2/issue/${{ env.jira_issue_key }}")
          
          ticket_summary=$(echo $response | jq -r '.fields.summary')
          ticket_description=$(echo $response | jq -r '.fields.description')
          ticket_type=$(echo $response | jq -r '.fields.issuetype.name')
          if [ -z "$ticket_summary" ]; then
            echo "Failed to fetch JIRA issue details."
            exit 1
          fi
          echo "ticket_summary=$ticket_summary" >> $GITHUB_ENV
          echo "ticket_description=$ticket_description" >> $GITHUB_ENV
          echo "ticket_type=$ticket_type" >> $GITHUB_ENV
      #   shell: bash
  
      - name: Get Release
        id: get-release
        uses: actions/github-script@v7
        with:
          script: |
            const tag = '${{ needs.version-tag.outputs.version }}';
            const release = await github.rest.repos.getReleaseByTag({
              owner: '${{ github.repository_owner }}',
              repo: '${{ github.event.repository.name }}',
              tag: tag
            });
            if (!release || !release.data.body) {
                console.error('Invalid release');
                return;
            }
            console.log(release.data.body);
            return {
                body: release.data.body,
                url: `https://github.com/${{ github.repository_owner }}/${{ github.event.repository.name }}/releases/tag/${tag}`
            };
  
      - name: Post Release Notes to Confluence
        id: post_to_confluence
        shell: bash
        env:
          RELEASE_NOTES: ${{ fromJson(steps.get-release.outputs.result).body }}
          RELEASE_URL: ${{ fromJson(steps.get-release.outputs.result).url }}
          PR_DESCRIPTION: ${{ steps.get_pr_data.outputs.background }}"
          COMMIT_DETAILS: ${{ needs.version-tag.outputs.commit_details }}
          TICKET_SUMMARY: ${{ env.ticket_summary }}
          TICKET_DESCRIPTION: ${{ env.ticket_description }}
          TICKET_ISSUE_KEY: ${{ env.jira_issue_key }}
          TICKET_TYPE: ${{ env.ticket_type }}
        run: |
          COMMIT_DETAILS=$(echo "${COMMIT_DETAILS}" | sed 's/\\:/:/g')
          PR_DESCRIPTION=$(echo "${PR_DESCRIPTION}" | awk '/### Background/,/###/' | sed -e '1d' -e '$d')
          RELEASE_NOTES="âœ… New *${{ github.event.repository.name }}* Release [${{ needs.version-tag.outputs.version }}](${RELEASE_URL}) $(date)\n${RELEASE_NOTES}\n\n*Commit Details*:\n${COMMIT_DETAILS}\n\n*Pr Description*:\n${PR_DESCRIPTION}\n\n*Feature Description:\n${TICKET_SUMMARY}\n${TICKET_DESCRIPTION}*"
  
          # if [ "$TICKET_TYPE" == "Epic" ]; then
          #     echo "TICKET_TYPE is 'Epic', calling Jira API..."
          #     jira_response=$(curl --request GET \
          #         --url "https://agrim.atlassian.net/rest/api/2/search?jql=parent=$TICKET_ISSUE_KEY&fields=summary,status,assignee,self" \
          #         --user '${{ vars.CONFLUENCE_EMAIL }}:${{ secrets.CONFLUENCE_API_TOKEN }}' \
          #         --header 'Accept: application/json')
          
          #     echo "Jira API Response: $jira_response"
          #     extracted_data=$(echo "$jira_response" | jq -r '.issues[] | {key: .key, status: .fields.status.name, summary: .fields.summary, assignee: .fields.assignee.displayName, assignee_username: .fields.assignee.name, self: .self}')
              
          #     FORMATTED_JIRA_ISSUES=$(echo "${extracted_data}" | awk '
          #       BEGIN {
          #         print "|| Issue || Status || Assignee ||";
          #       }
          #       {
          #         if ($1 == "{") { in_jira=1; issue_link=""; status=""; assignee=""; }
          #         if (in_jira && $1 == "\"key\":") {
          #           gsub(/,$/, "", $2);
          #           issue_link=sprintf("[[%s|%s]]", $4, $2);
          #         }
          #         if (in_jira && $1 == "\"status\":") {
          #           gsub(/,$/, "", $2);
          #           status=$2;
          #         }
          #         if (in_jira && $1 == "\"summary\":") {
          #           gsub(/,$/, "", $2);
          #           issue_link=sprintf("[%s|%s]", $3, $4);
          #         }
          #         if (in_jira && $1 == "\"assignee\":") {
          #           gsub(/,$/, "", $2);
          #           assignee=sprintf("[~%s]", $4);
          #         }
          #         if (in_jira && $1 == "\"assignee_username\":") {
          #           gsub(/,$/, "", $2);
          #           assignee=sprintf("[~%s]", $2);
          #         }
          #         if (in_jira && $1 == "\"self\":") {
          #           print "| " issue_link " | " status " | " assignee " |";
          #           in_jira=0;
          #         }
          #       }'
          #     )
              
          #     RELEASE_NOTES="${RELEASE_NOTES}\n\nJira Issues:\n$FORMATTED_JIRA_ISSUES"
          # fi
          echo "Data: $RELEASE_NOTES"
          RELEASE_NOTES=$(echo -e "${RELEASE_NOTES}" | \
            sed 's/## //g' | \
            sed -E 's/<[^>]*>//g' | \
            sed -E 's/\[([^]]+)\]\(([^)]+)\)/[\1|\2]/g' | \
            sed -E 's/@([^ ]+)/[@\1|https:\/\/github.com\/\1]/g' | \
            sed 's/\\n/\n/g')
          echo "Data: $RELEASE_NOTES"
  
          payload=$(jq -n \
          --arg spaceId "163842" \
          --arg status "current" \
          --arg title "Release: ${{ needs.version-tag.outputs.version }}" \
          --arg parentId "163998" \
          --arg value "$RELEASE_NOTES" \
          '{
              "spaceId": $spaceId,
              "status": $status,
              "title": $title,
              "parentId": $parentId,
              "body": {
                "representation": "wiki",
                "value": $value
              }
          }')
  
          echo "Payload: $payload"
  
          response=$(curl --request POST \
              --url 'https://agrim.atlassian.net/wiki/api/v2/pages' \
              --user '${{ vars.CONFLUENCE_EMAIL }}:${{ secrets.CONFLUENCE_API_TOKEN }}' \
              --header 'Accept: application/json' \
              --header 'Content-Type: application/json' \
              --data "$payload")
          echo "Response: $response"
          pageId=$(echo "$response" | jq -r '.id')
          if [ "$pageId" == "null" ]; then
            echo "Failed to create page"
            exit 1
          fi
          echo "pageId=$pageId" >> $GITHUB_ENV
